---
title: cJSON API 接口使用说明
tags: cjson c
---

# cJSON API 接口使用说明

### cJSON的介绍

cJSON是一个轻量级的JSON解析器使用ANSIC标准。

所谓的轻量级，如果你的项目需要使用到解析JSON，那么只需要将cJSON的库中的`cJSON.h`和`cJSON.c`放入到你的项目中适当的位置就行了。

目前介绍的cJSON的版本为`1.5.7`。

cJSON库的项目的github地址为：[cJSON](https://github.com/DaveGamble/cJSON/releases)

在项目的过程中还使用都了shell文件的解析JSON的库，也是轻量级的就是一个JSON.sh文件。

有兴趣的可以看一下这个shell的JSON库， [JSON.sh](https://github.com/dominictarr/JSON.sh)

现在已经有了各种语言的解析的JSON的库，大家可以自行到github上面搜索


### 为什么介绍cJSON

在项目中需要使用到cJSON的解析JSON库，但是总感觉有点用起来不顺手，所以就自己写些demo来使用这些接口。

主要一些cJSON的接口使用到内存分配的问题，所以特别要注意，而且就在`1.5.7`刚刚修复了一个内存的问题。

组内还在讨论要不要，把cJSON的问题再升级一下。

自己做了写了一些非常简陋并且丑陋的example代码，[link](https://github.com/jhlpotato/my_code) 下面的cjson文件下

<!-- more  -->

### cJSON API 使用总结

| cJSON API | 说明 | 备注 |
| --------- | ---- | ---- |
| `cJSON_Version()` 		| 获得cJSON的版本 						| 返回字符串常量 |
| `cJSON_InitHooks();` 		| 初始化cJSON_Hooks结构体 				| 没太明白 	|
| `cJSON_Parse();`			| 将字符串解析成cJSON结构体				| 	|
| `cJSON_ParseWithOpts()`	| 使用一些配置解析字符串 				| 	|
| `cJSON_Print()`			| 将cJSON结构体转换成格式化的字符串		| 	|
| `cJSON_PrintUnformatted()`| 将cJSON结构体转换成未格式化的字符串	| 	|
| `cJSON_PrintBuffered()`	| 将cJSON结构体使用buffer的字符串，格式化可选	|	|
| `cJSON_PrintPreallocated()`	| 将cJSON结构体使用预分配的内存的字符串，格式化可选	| 	|
| `cJSON_Delete()`				| 删除cJSON结构体									| 删除子对象，所有都会删除 |
| `cJSON_GetArraySize()`		| 返回Array类型的大小,对Object类型也是有效的		|	|
| `cJSON_GetArrayItem()`		| 返回Array类型的index的值，对Object类型也有效		| 	|
| `cJSON_GetObjectItem()`		| 使用key获得对应的value						|	|
| `cJSON_GetObjectItemCaseSensitive()`	| 使用对大小写敏感的key获得对应的value	|	|
| `cJSON_HasObjectItem()`				| 判断是否ObjectItem存在				|	|
| `cJSON_GetErrorPtr()`					| 获得错误信息							|	|
| `cJSON_IsInvalid()`					| 类型判断								|	|
| `cJSON_IsFalse()`						| 类型判断								|	|
| `cJSON_IsTrue()`						| 类型判断								|	|
| `cJSON_IsBool()`						| 类型判断								|	|
| `cJSON_IsNull()`						| 类型判断								|	|
| `cJSON_IsNumber()`					| 类型判断								|	|
| `cJSON_IsString()`					| 类型判断								|	|
| `cJSON_IsArray()`						| 类型判断								|	|
| `cJSON_IsObject()`					| 类型判断								|	|
| `cJSON_IsRaw()`						| 类型判断								|	|
| `cJSON_CreateNull()`					| 创造对应类型的cJSON					|	|
| `cJSON_CreateTrue()`					| 创造对应类型的cJSON					|	|
| `cJSON_CreateFalse()`					| 创造对应类型的cJSON					|	|
| `cJSON_CreateBool()`					| 创造对应类型的cJSON					|	|
| `cJSON_CreateNumber()`				| 创造对应类型的cJSON					|	|
| `cJSON_CreateString()`				| 创造对应类型的cJSON					|	|
| `cJSON_CreateRaw()`					| 创造对应类型的cJSON					|	|
| `cJSON_CreateArray()`					| 创造对应类型的cJSON					|	|
| `cJSON_CreateObject()`				| 创造对应类型的cJSON					|	|
| `cJSON_CreateIntArray()`				| 批量创造对应类型的cJSON				|	|
| `cJSON_CreateFloatArray()`			| 批量创造对应类型的cJSON				|	|
| `cJSON_CreateDoubleArray()`			| 批量创造对应类型的cJSON				|	|
| `cJSON_CreateStringArray()`			| 批量创造对应类型的cJSON				|	|
| `cJSON_AddItemToArray()`				| 在指定Array后面增加Item				|	|
| `cJSON_AddItemToObject()`				| 在指定Object后面增加Item				|	|
| `cJSON_AddItemToObjectCS()`			| 在指定Object后面增加const Item 		|	|
| `cJSON_AddItemReferenceToArray()`		| 在指定Array后面增加Item引用			|	|
| `cJSON_DetachItemViaPointer()`		| 通过指针从Array删除Item的引用			| 这个自己理解 |
| `cJSON_DetachItemFromArray()`			| 从Array删除Item的引用				|	|
| `cJSON_DeleteItemFromArray()`			| 从Array删除Item 					|	|
| `cJSON_DetachItemFromObject()`		| 从Object删除Item的引用			|	|
| `cJSON_DetachItemFromObjectCaseSensitive()`	| 大小写敏感的从Object删除Item的引用	|	|
| `cJSON_DeleteItemFromObject()`				| 从Object删除Item 						|	|
| `cJSON_DeleteItemFromObjectCaseSensitive()`	| 大小写敏感的从Object删除Item 			|	|
| `cJSON_InsertItemInArray()`					| 在Array指定位置插入Item				|	|
| `cJSON_ReplaceItemViaPointer()`				| 使用指针替代Item						|	|
| `cJSON_ReplaceItemInArray()`					| 替换Array的Item						|	|
| `cJSON_ReplaceItemInObject()`					| 替换Object的Item						|	|
| `cJSON_ReplaceItemInObjectCaseSensitive()		| 大小写敏感的替换Object的Item			|	|
| `cJSON_Duplicate()`							| 复制cJSON结构体						|	|
| `cJSON_Compare()`								| 比较两个cJSON结构体					|	|
| `cJSON_Minify()`								| 将格式化的字符串压缩					|	|
| `cJSON_AddNullToObject()`						| 调用cJSON_AddItemToObject和cJSON_CreateNull	|	|
| `cJSON_AddTrueToObject()`						| 调用cJSON_AddItemToObject和cJSON_CreateTrue	|	|
| `cJSON_AddFalseToObject()`					| 调用cJSON_AddItemToObject和cJSON_CreateFalse	|	|
| `cJSON_AddBoolToObject()`						| 调用cJSON_AddItemToObject和cJSON_CreateBool	|	|
| `cJSON_AddNumberToObject()`					| 调用cJSON_AddItemToObject和cJSON_CreateNumber	|	|	
| `cJSON_AddStringToObject()`					| 调用cJSON_AddItemToObject和cJSON_CreateString	|	|	
| `cJSON_AddRawToObject()`						| 调用cJSON_AddItemToObject和cJSON_CreateRaw	|	|	
| `cJSON_SetIntValue()`							| 设置int的值，同时也设置double的值				|	|	
| `cJSON_SetNumberValue()`						| 后台会调用cJSON_SetNumberHelper				|	|	
| `cJSON_SetNumberHelper()`						| 设置cJSON的number类型的值						|	|	
| `cJSON_malloc()`								| cJSON的malloc函数，调用malloc函数				|	|
| `cJSON_free()`								| cJSON的free函数，调用free函数					|	|

### cJSON 一些实现原理
1. cJSON有九种类型
- `Invalid`类型
- `False`类型
- `True`类型
- `Null`类型
- `Number`类型
- `String`类型
- `Array`类型
- `Object`类型
- `Raw`类型

主要使用移位来表示的，同时使用&0xFF来判断类型的
还有两个`cJSON_IsReference`和`cJSON_StringIsConst`的宏定义,看名字是判断是否是引用和是否是常量字符串

2. cJSON最主要的结构体 `struct cJSON`

已经注释的非常清楚了
总体来说，并列层级的第一个是孩子，其他的都是这个孩子的兄弟的结构。
 
 | 成员变量 | 说明 |
 | -------- | ---- |
 | next     | 同一层级相邻的下一个兄弟 |
 | prev     | 同一层级相邻的上一个兄弟 |
 | child    | 本节点的孩子，只有一个孩子 | 
 | type     | 本节点的类型               |
 | valuestring | 将string类型和raw类型的变量转换成字符串 |
 | valueint    | 将int类型的cjson转换成int类型，已经废弃，为了兼容老版本，可以使用cJSON_SetNumberValue替代赋值 |
 | valuedouble | 同上，可以代替int类型 |
 | string      | 本节点的名字 |

```
/* The cJSON structure: */
typedef struct cJSON
{
    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
    struct cJSON *next;
    struct cJSON *prev;
    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
    struct cJSON *child;

    /* The type of the item, as above. */
    int type;

    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */
    char *valuestring;
    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
    int valueint;
    /* The item's number, if type==cJSON_Number */
    double valuedouble;

    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
    char *string;
} cJSON;
```

3. 结构体 struct cJSON_Hooks
定义了两个函数指针，一个malloc和free
不知道怎么用

4. cJSON_bool 本质就是 int类型

5. 还设置了windows环境下编译的一些参数，看不懂。。

6. 然后还是`#define`设置了不同情况下给每个函数增加不同的环境设置参数，使用CJSON_PUBLIC包裹

7. 限制了嵌套层数，不能超过1000层

8. object与array的区别

object是一个key和value对应的键值对，例如 `{ "key1": "value1", "key2": "value2" }`

array是一个数据的概念，数据的集合，例如 `[ "value1", "value2" ]`
